<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>最大似然法 + Logistic回归｜互动教学站</title>
  <style>
    :root{
      --bg:#0b1020; --card:#121a33; --muted:#8fa3d8; --text:#e7ecff; --brand:#7aa2ff; --accent:#86efac; --ink:#dbe4ff;
    }
    *{box-sizing:border-box}
    body{margin:0;font-family:system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial,"Noto Sans",sans-serif;background:linear-gradient(180deg,#0b1020,#0b1020 60%,#0e1430);color:var(--text)}
    header{position:sticky;top:0;background:rgba(11,16,32,.7);backdrop-filter:saturate(160%) blur(10px);border-bottom:1px solid rgba(255,255,255,.06);z-index:50}
    nav{max-width:1200px;margin:auto;display:flex;gap:12px;align-items:center;padding:12px 16px}
    nav a{color:var(--muted);text-decoration:none;padding:8px 10px;border-radius:10px}
    nav a:hover{background:rgba(122,162,255,.12);color:#cfe0ff}
    .brand{font-weight:700;color:#cfe0ff;margin-right:auto;letter-spacing:.3px}
    main{max-width:1200px;margin:28px auto;padding:0 16px 60px}
    h1{font-size:clamp(24px,2.6vw,36px);margin:8px 0 16px}
    h2{margin:24px 0 12px;font-size:clamp(20px,2.2vw,28px)}
    h3{margin:18px 0 10px}
    p.lead{color:#cfe0ff;opacity:.9}
    .grid{display:grid;gap:16px}
    @media(min-width:980px){.grid.cols-2{grid-template-columns:1.05fr .95fr}.grid.cols-3{grid-template-columns:repeat(3,1fr)}}
    .card{background:linear-gradient(180deg,var(--card),#0c1430);border:1px solid rgba(255,255,255,.06);border-radius:16px;box-shadow:0 10px 30px rgba(0,0,0,.35)}
    .card .hd{padding:14px 16px;border-bottom:1px solid rgba(255,255,255,.06);display:flex;align-items:center;gap:10px}
    .pill{font-size:12px;color:#0b1020;background:var(--accent);padding:2px 8px;border-radius:999px;font-weight:700}
    .card .bd{padding:14px 16px}
    .muted{color:var(--muted)}
    .row{display:flex;gap:10px;flex-wrap:wrap}
    input,select,textarea{background:#0b1433;color:#e8eeff;border:1px solid rgba(255,255,255,.1);padding:10px 12px;border-radius:12px}
    textarea{width:100%;min-height:120px;font-family:ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas,"Liberation Mono","Courier New", monospace}
    label{font-size:13px;color:#cdd8ff}
    .kpi{display:grid;grid-template-columns:repeat(3,minmax(0,1fr));gap:10px}
    .kpi .box{background:#0a132c;border:1px dashed rgba(255,255,255,.12);border-radius:12px;padding:10px}
    .kpi .val{font-weight:800;font-size:20px}
    canvas{width:100%;height:360px;background:#0a1228;border-radius:12px}
    .tip{font-size:12px;color:#a9b8ff}
    .btn{display:inline-flex;align-items:center;gap:8px;background:#16244d;color:#dce6ff;border:1px solid rgba(255,255,255,.08);padding:10px 14px;border-radius:12px;cursor:pointer}
    .btn:hover{background:#1a2a59}
    details{background:#0a132c;border:1px solid rgba(255,255,255,.08);border-radius:12px;padding:8px 12px}
    summary{cursor:pointer;color:#cfe0ff}
    footer{max-width:1200px;margin:40px auto 80px;color:#93a8e9;padding:0 16px}
    code{background:#0b1433;border:1px solid rgba(255,255,255,.08);padding:2px 6px;border-radius:8px}
    .mono{font-family:ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace}
  </style>
  <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.1/dist/chart.umd.min.js"></script>
</head>
<body>
  <header>
    <nav>
      <div class="brand">最大似然法 + Logistic回归 · 互动课件</div>
      <a href="#mle">最大似然法</a>
      <a href="#logit">Logistic 回归</a>
      <a href="#tests">参数检验</a>
      <a href="#diag">诊断与注意事项</a>
      <a href="#practice">练一练</a>
    </nav>
  </header>

  <main>
    <section>
      <h1>最大似然法（MLE）与 Logistic 回归</h1>
      <p class="lead">本页将课堂要点做成可视化交互：从<b>似然/对数似然曲线</b>到<b>Logistic 回归的拟合</b>（牛顿-拉夫逊/IRLS）、<b>OR 与 95%CI</b>、<b>Wald vs 似然比检验(LRT)</b>、<b>损失/收敛曲线</b>与<b>分界线</b>。输入你自己的数据或使用示例，一键看到结果与图形。</p>
    </section>

    <!-- MLE 基础演示 -->
    <section id="mle" class="grid cols-2" style="margin-top:18px">
      <div class="card">
        <div class="hd"><span class="pill">MLE</span><strong>分布选择 + 似然曲线</strong></div>
        <div class="bd">
          <div class="row">
            <div>
              <label>分布</label><br>
              <select id="distSel">
                <option value="bern">Bernoulli（0/1）</option>
                <option value="binom">Binomial（n 次，x 成功）</option>
                <option value="pois">Poisson（计数）</option>
                <option value="norm">Normal（均值未知，方差已知）</option>
              </select>
            </div>
            <div id="bernBox">
              <label>样本（逗号分隔，0/1）</label><br>
              <input id="bernData" value="1,0,1,1,0,1,0,1,1,0" style="width:360px">
            </div>
            <div id="binomBox" style="display:none">
              <label>Binomial: n, x</label><br>
              <input id="binomN" type="number" value="50" min="1"> <input id="binomX" type="number" value="21" min="0">
            </div>
            <div id="poisBox" style="display:none">
              <label>样本（计数）</label><br>
              <input id="poisData" value="3,1,0,2,4,2,1,3,0,1" style="width:360px">
            </div>
            <div id="normBox" style="display:none">
              <label>样本（逗号分隔），σ 已知：</label><br>
              <input id="normData" value="0.2, -0.1, 0.5, 0.3, -0.4, 0.0, 0.7"> σ=<input id="normSigma" type="number" value="1" step="0.1" style="width:80px">
            </div>
          </div>
          <div class="kpi" style="margin-top:10px">
            <div class="box"><div class="muted">MLE 参数</div><div class="val" id="mleTheta">—</div><div class="tip">使对数似然最大化的参数估计</div></div>
            <div class="box"><div class="muted">对数似然最大值</div><div class="val" id="maxLL">—</div><div class="tip">log L(θ̂)</div></div>
            <div class="box"><div class="muted">Fisher信息(近似)</div><div class="val" id="fisher">—</div><div class="tip">可近似给出 SE(θ̂)</div></div>
          </div>
          <div class="row" style="margin-top:10px">
            <button class="btn" onclick="drawLikelihood()">计算并绘图</button>
            <button class="btn" onclick="loadMLEExample()">填入示例</button>
          </div>
          <details style="margin-top:10px"><summary>课堂要点</summary>
            <ul>
              <li>似然衡量“在给定参数下，数据出现的可能性”。MLE 取使似然（或对数似然）最大的参数。</li>
              <li>对数似然更便于求和与优化；Fisher 信息的倒数近似为估计量方差。</li>
            </ul>
          </details>
        </div>
      </div>
      <div class="card">
        <div class="hd"><span class="pill">CHART</span><strong>似然/对数似然曲线</strong></div>
        <div class="bd">
          <canvas id="likeChart"></canvas>
          <div class="tip" style="margin-top:8px">蓝线：对数似然；红点：MLE 位置；灰虚线：参数轴网格。</div>
        </div>
      </div>
    </section>

    <!-- Logistic 回归 -->
    <section id="logit" class="grid cols-2" style="margin-top:22px">
      <div class="card">
        <div class="hd"><span class="pill">LOGISTIC</span><strong>数据输入 + 拟合 (IRLS)</strong></div>
        <div class="bd">
          <p class="muted">数据格式：CSV，每行  <code>y,x1,x2</code>（y∈{0,1}；x1/x2 可为空，自动补常数项）。建议不超过 1000 行。</p>
          <textarea id="csvInput" class="mono">1, 0.5, 1.2
0, -0.2, -0.8
1, 1.0, 0.6
0, -0.5, -0.4
1, 1.2, 0.3
0, -0.8, -1.1
1, 0.9, 0.4
0, -0.6, -0.9
1, 0.7, 0.8
0, -0.7, -0.5</textarea>
          <div class="row" style="margin-top:10px">
            <label>最大迭代</label><input id="maxIt" type="number" value="50" style="width:90px">
            <label>收敛阈值</label><input id="tol" type="number" value="1e-6" step="1e-6" style="width:120px">
            <button class="btn" onclick="fitLogistic()">拟合模型</button>
            <button class="btn" onclick="loadDemoData()">示例数据</button>
          </div>
          <div class="kpi" style="margin-top:10px">
            <div class="box"><div class="muted">对数似然</div><div class="val" id="logLik">—</div><div class="tip">收敛后的 log L(β̂)</div></div>
            <div class="box"><div class="muted">迭代次数</div><div class="val" id="iters">—</div><div class="tip">IRLS / 牛顿-拉夫逊</div></div>
            <div class="box"><div class="muted">AIC</div><div class="val" id="aic">—</div><div class="tip">-2logL + 2k</div></div>
          </div>
          <div style="margin-top:10px">
            <table id="coefTable" class="mono" style="width:100%;border-collapse:collapse">
              <thead>
                <tr><th style="text-align:left;padding:6px;border-bottom:1px solid rgba(255,255,255,.15)">变量</th><th>β̂</th><th>SE</th><th>OR=exp(β̂)</th><th>95%CI(OR)</th><th>Wald z</th><th>p</th></tr>
              </thead>
              <tbody id="coefBody"></tbody>
            </table>
            <div class="tip" style="margin-top:6px">若检测到完全分离/准分离，会给出警告。</div>
          </div>
        </div>
      </div>
      <div class="card">
        <div class="hd"><span class="pill">CHART</span><strong>收敛曲线 / 决策边界</strong></div>
        <div class="bd">
          <canvas id="lossChart"></canvas>
          <div class="tip" style="margin:8px 0 4px">上图：-对数似然随迭代下降；下图：仅在存在 x1、x2 时绘制二维分界线。</div>
          <canvas id="boundaryChart" style="height:380px"></canvas>
        </div>
      </div>
    </section>

    <!-- 参数检验：Wald vs LRT vs Score -->
    <section id="tests" class="grid cols-2" style="margin-top:22px">
      <div class="card">
        <div class="hd"><span class="pill">TESTS</span><strong>Wald / LRT / Score（单参数 H0: βj=0）</strong></div>
        <div class="bd">
          <div class="row">
            <label>选择参数</label>
            <select id="paramSel"></select>
            <button class="btn" onclick="runTests()">计算检验量</button>
          </div>
          <div class="kpi" style="margin-top:10px">
            <div class="box"><div class="muted">Wald z</div><div class="val" id="waldZ">—</div><div class="tip">z = β̂/SE(β̂)</div></div>
            <div class="box"><div class="muted">LRT χ²(1)</div><div class="val" id="lrtChi">—</div><div class="tip">2[logL(β̂) - logL(βj=0)]</div></div>
            <div class="box"><div class="muted">Score χ²(1)</div><div class="val" id="scoreChi">—</div><div class="tip">U(0)^T I(0)^{-1} U(0)</div></div>
          </div>
          <details style="margin-top:10px"><summary>课堂要点</summary>
            <ul>
              <li>Wald 基于估计量的渐近正态；LRT 基于嵌套模型对数似然差；Score 基于原点的导数信息。</li>
              <li>样本较小或分离时，Wald 不稳定，LRT/Score 更稳健。</li>
            </ul>
          </details>
        </div>
      </div>
      <div class="card">
        <div class="hd"><span class="pill">CHART</span><strong>检验概念图</strong></div>
        <div class="bd">
          <canvas id="testChart"></canvas>
          <div class="tip">蓝：全模型 logL；橙：约束模型 logL（βj=0）；虚线：Score 的切线近似。</div>
        </div>
      </div>
    </section>

    <!-- 诊断与注意事项 -->
    <section id="diag" class="grid cols-2" style="margin-top:22px">
      <div class="card">
        <div class="hd"><span class="pill">DIAGNOSTICS</span><strong>常见问题</strong></div>
        <div class="bd">
          <ul>
            <li><b>完全分离/准分离</b>：某线性组合将 0/1 完全分开 → MLE 不存在或极大；可尝试惩罚/贝叶斯或删改变量。</li>
            <li><b>多重共线</b>：系数方差膨胀，Wald 不稳 → 检查相关矩阵/VIF；必要时降维或正则化。</li>
            <li><b>模型设定</b>：缺失高阶项/交互项会导致偏误；可通过 AIC、残差图、交叉验证比较。</li>
            <li><b>样本量</b>：每参数事件数（EPV）太小会导致偏倚 → 适当增加样本或用偏倚校正。</li>
          </ul>
          <div class="row" style="margin-top:8px">
            <button class="btn" onclick="showCorr()">查看 X 相关性</button>
            <button class="btn" onclick="warns && alert(warns.join('\n'))">查看警告</button>
          </div>
          <pre id="corrBox" class="mono" style="white-space:pre-wrap"></pre>
        </div>
      </div>
      <div class="card">
        <div class="hd"><span class="pill">FORMULA</span><strong>模型与链接函数</strong></div>
        <div class="bd">
          <p>Logistic 模型：<span class="mono">logit(p) = log(p/(1-p)) = β0 + β1 x1 + β2 x2</span>；<br> 概率：<span class="mono">p = 1/(1+e^{-(β0+β1 x1 + β2 x2)})</span>。</p>
          <p>极大似然：<span class="mono">ℓ(β) = Σ [ y_i log p_i + (1-y_i) log(1-p_i) ]</span>，用 IRLS/Newton-Raphson 迭代求 β̂。</p>
        </div>
      </div>
    </section>

    <!-- 练习区 -->
    <section id="practice" style="margin-top:22px">
      <div class="card">
        <div class="hd"><span class="pill">PRACTICE</span><strong>快速自测</strong></div>
        <div class="bd">
          <ol>
            <li>在“MLE”中选 Bernoulli，随机输入 0/1 样本，找到 θ̂ 并观察对数似然曲线形状。</li>
            <li>使用“Logistic 回归”，输入两类点（x1,x2），拟合分界线；查看 OR 与 95%CI。</li>
            <li>在“参数检验”中对 β1 做 Wald 与 LRT 比较，观察 p 值差异。</li>
          </ol>
        </div>
      </div>
    </section>
  </main>

  <footer>
    <p>© <span id="yr"></span> 最大似然法 + Logistic 回归 · 互动教学 | 作者：Zhenti CUI | 课程网站用 | 本页为静态 HTML，可直接部署到 GitHub Pages。</p>
  </footer>

<script>
  const $ = (s)=>document.querySelector(s);
  const yrEl = document.getElementById('yr'); yrEl.textContent = new Date().getFullYear();

  // ===== UI 切换 for MLE panels =====
  const boxes = {bern: '#bernData', binom: ['#binomN','#binomX'], pois: '#poisData', norm: ['#normData','#normSigma']};
  function syncDistUI(){
    const v = $('#distSel').value;
    ['bernBox','binomBox','poisBox','normBox'].forEach(id=> document.getElementById(id).style.display='none');
    if(v==='bern') $('#bernBox').style.display='block';
    if(v==='binom') $('#binomBox').style.display='block';
    if(v==='pois') $('#poisBox').style.display='block';
    if(v==='norm') $('#normBox').style.display='block';
  }
  $('#distSel').addEventListener('change', syncDistUI);
  syncDistUI();

  // ===== Chart.js handles =====
  let likeChart, lossChart, boundaryChart, testChart;

  // ===== Helpers =====
  const mean = arr => arr.reduce((s,x)=>s+x,0)/arr.length;
  const sum = arr => arr.reduce((s,x)=>s+x,0);
  const clamp=(x,a,b)=>Math.max(a,Math.min(b,x));
  function parseNums(str){
    return str.split(/[,\s]+/).map(s=>s.trim()).filter(Boolean).map(Number);
  }

  // ===== MLE computations =====
  function bernLL(p, data){
    if(p<=0 || p>=1) return -1e12;
    let ll=0; for(const y of data){ if(y===1) ll+=Math.log(p); else ll+=Math.log(1-p); }
    return ll;
  }
  function binomLL(p, n, x){
    if(p<=0 || p>=1) return -1e12; // C(n,x) 常数，忽略
    return x*Math.log(p) + (n-x)*Math.log(1-p);
  }
  function poisLL(lmb, data){
    if(lmb<=0) return -1e12;
    let ll=0; for(const y of data){ ll += y*Math.log(lmb) - lmb; } // -log(y!) 常数
    return ll;
  }
  function normLL(mu, data, sigma){
    const n=data.length; const s2=sigma*sigma; let ll=0;
    for(const y of data){ ll += -0.5*Math.log(2*Math.PI*s2) - (y-mu)*(y-mu)/(2*s2); }
    return ll;
  }

  function loadMLEExample(){
    const v=$('#distSel').value;
    if(v==='bern') $('#bernData').value='1,0,1,1,0,1,0,1,1,0';
    if(v==='binom'){ $('#binomN').value=50; $('#binomX').value=21; }
    if(v==='pois') $('#poisData').value='3,1,0,2,4,2,1,3,0,1';
    if(v==='norm'){ $('#normData').value='0.2,-0.1,0.5,0.3,-0.4,0.0,0.7'; $('#normSigma').value=1; }
    drawLikelihood();
  }

  function drawLikelihood(){
    const v=$('#distSel').value; let xs=[], ll=[], thetaHat, maxll, fish;
    if(v==='bern'){
      const data=parseNums($('#bernData').value); const pHat = mean(data);
      for(let p=0.001;p<=0.999;p+=0.005){ xs.push(p); ll.push(bernLL(p,data)); }
      thetaHat=pHat; maxll=bernLL(pHat,data); fish = data.length/(pHat*(1-pHat));
    }
    if(v==='binom'){
      const n=+$('#binomN').value||1, x=+$('#binomX').value||0; const pHat = x/Math.max(1,n);
      for(let p=0.001;p<=0.999;p+=0.005){ xs.push(p); ll.push(binomLL(p,n,x)); }
      thetaHat=pHat; maxll=binomLL(pHat,n,x); fish = n/(pHat*(1-pHat));
    }
    if(v==='pois'){
      const data=parseNums($('#poisData').value); const lam = mean(data);
      for(let l=0.05;l<=8;l+=0.05){ xs.push(l); ll.push(poisLL(l,data)); }
      thetaHat=lam; maxll=poisLL(lam,data); fish = data.length/lam;
    }
    if(v==='norm'){
      const data=parseNums($('#normData').value); const s=+$('#normSigma').value||1; const muHat = mean(data);
      for(let mu=muHat-3*s; mu<=muHat+3*s; mu+= s/20){ xs.push(mu); ll.push(normLL(mu,data,s)); }
      thetaHat=muHat; maxll=normLL(muHat,data,s); fish = data.length/(s*s);
    }
    $('#mleTheta').textContent = thetaHat!==undefined? (''+thetaHat.toFixed(4)) : '—';
    $('#maxLL').textContent = maxll!==undefined? (''+maxll.toFixed(3)) : '—';
    $('#fisher').textContent = fish!==undefined && isFinite(fish)? fish.toFixed(2) : '—';

    const minY=Math.min(...ll), maxY=Math.max(...ll);
    const cfg={type:'line', data:{labels:xs, datasets:[{label:'log-likelihood', data: ll, fill:false}]}, options:{responsive:true, scales:{x:{title:{display:true, text:'参数 θ'}}, y:{title:{display:true, text:'对数似然'}}}, plugins:{legend:{display:false}}}};
    if(likeChart) likeChart.destroy(); likeChart=new Chart($('#likeChart'), cfg);
    // draw MLE marker
    const ctx=likeChart.ctx; const xscale=likeChart.scales.x, yscale=likeChart.scales.y;
    const x=xscale.getPixelForValue(thetaHat); const y=yscale.getPixelForValue(maxll);
    ctx.save(); ctx.fillStyle='#fca5a5'; ctx.beginPath(); ctx.arc(x,y,4,0,Math.PI*2); ctx.fill(); ctx.restore();
  }

  // ===== Logistic fitting (IRLS) =====
  let lastModel=null, warns=[];
  function loadDemoData(){
    $('#csvInput').value = `1, 0.5, 1.2\n0, -0.2, -0.8\n1, 1.0, 0.6\n0, -0.5, -0.4\n1, 1.2, 0.3\n0, -0.8, -1.1\n1, 0.9, 0.4\n0, -0.6, -0.9\n1, 0.7, 0.8\n0, -0.7, -0.5`;
  }
  function parseCSV(){
    const lines = $('#csvInput').value.split(/\n+/).map(s=>s.trim()).filter(Boolean);
    const Y=[], X=[]; let hasX1=false, hasX2=false;
    for(const ln of lines){
      const parts=ln.split(',').map(s=>s.trim()).filter(s=>s.length>0);
      const y=Number(parts[0]); const x1 = parts.length>1? Number(parts[1]):0; const x2 = parts.length>2? Number(parts[2]):0;
      if(!(y===0 || y===1) || !isFinite(x1) || !isFinite(x2)) continue;
      Y.push(y); X.push([1, x1, x2]); if(parts.length>1) hasX1=true; if(parts.length>2) hasX2=true;
    }
    return {Y, X, hasX1, hasX2};
  }
  function sigmoid(z){ return 1/(1+Math.exp(-z)); }
  function matVecMul(A, v){ return A.map(row=> row.reduce((s, aij, j)=> s + aij*v[j], 0)); }
  function transpose(A){ const m=A.length, n=A[0].length; const T=Array.from({length:n},()=>Array(m)); for(let i=0;i<m;i++) for(let j=0;j<n;j++) T[j][i]=A[i][j]; return T; }
  function matMul(A,B){ const m=A.length, n=A[0].length, p=B[0].length; const C=Array.from({length:m},()=>Array(p).fill(0)); for(let i=0;i<m;i++) for(let k=0;k<n;k++) for(let j=0;j<p;j++) C[i][j]+=A[i][k]*B[k][j]; return C; }
  function invSym3(S){ // 3x3 对称矩阵求逆
    const a=S[0][0], b=S[0][1], c=S[0][2], d=S[1][1], e=S[1][2], f=S[2][2];
    const det = a*(d*f-e*e) - b*(b*f-c*e) + c*(b*e-c*d);
    if(Math.abs(det)<1e-12) return null;
    const inv=[[d*f-e*e, c*e-b*f, b*e-c*d],[c*e-b*f, a*f-c*c, b*c-a*e],[b*e-c*d, b*c-a*e, a*d-b*b]];
    for(let i=0;i<3;i++) for(let j=0;j<3;j++) inv[i][j]/=det; return inv;
  }
  function fitLogistic(){
    warns=[];
    const {Y, X, hasX1, hasX2} = parseCSV(); const n=Y.length; if(n===0){ alert('数据无效'); return; }
    const p = 1 + (hasX1?1:0) + (hasX2?1:0); // 参数个数：截距 + x1 + x2
    // 取前 p 列
    const Xuse = X.map(r=> r.slice(0,p));

    // 初值
    let beta = Array(p).fill(0);
    let lastLL=-Infinity; const maxIt=+$('#maxIt').value||50, tol=+$('#tol').value||1e-6;
    const negLoss=[];
    for(let it=0; it<maxIt; it++){
      const eta = matVecMul(Xuse, beta);
      const mu = eta.map(sigmoid);
      // 检测分离：概率极端接近0或1 且与 y 完全一致
      const near01 = mu.map(m=> (m<1e-6 || m>1-1e-6));
      if(near01.every((v,i)=> (v && ((mu[i]>0.5 && Y[i]===1) || (mu[i]<=0.5 && Y[i]===0))))){
        warns.push('检测到可能的完全分离：系数可能发散，Wald 不可靠。');
      }
      // 权重与工作响应
      const W = mu.map(m=> m*(1-m));
      const z = eta.map((e,i)=> e + (Y[i]-mu[i])/Math.max(W[i],1e-12));
      // 构造 Xt W X 与 Xt W z
      const Xt = transpose(Xuse);
      const WX = Xuse.map((row,i)=> row.map(v=> v*W[i]));
      const XtWX = matMul(Xt, WX);
      const XtWz = matVecMul(Xt, z.map((zi,i)=> zi*W[i]));
      // 求解 (XtWX) beta = XtWz —— 3x3 或 2x2
      let Hinv=null, delta=null;
      if(p===3){ Hinv = invSym3(XtWX); }
      else if(p===2){ // 简单 2x2 逆
        const a=XtWX[0][0], b=XtWX[0][1], c=XtWX[1][1]; const det=a*c-b*b; if(Math.abs(det)<1e-12) Hinv=null; else Hinv=[[c/det,-b/det],[-b/det,a/det]];
      } else { // 1x1
        Hinv = [[1/Math.max(XtWX[0][0],1e-12)]];
      }
      if(!Hinv){ warns.push('设计矩阵病态：无法稳定求解（共线或权重问题）。'); break; }
      delta = matVecMul(Hinv, XtWz);
      // 更新 beta
      for(let j=0;j<p;j++) beta[j]=delta[j];
      // 评估对数似然
      const ll = sum(mu.map((m,i)=> Y[i]*Math.log(clamp(m,1e-12,1-1e-12)) + (1-Y[i])*Math.log(clamp(1-m,1e-12,1-1e-12))));
      negLoss.push(-ll);
      if(Math.abs(ll-lastLL) < tol){
        // 收敛
        // 协方差矩阵近似：H^{-1}（此处 H≈XtWX）
        const cov = Hinv;
        showLogitResult(beta, cov, ll, it+1, Xuse, Y, hasX1, hasX2, negLoss);
        return;
      }
      lastLL=ll;
    }
    // 达到最大迭代
    const cov = null; showLogitResult(beta, cov, lastLL, maxIt, Xuse, Y, hasX1, hasX2, negLoss);
  }
  function matVecMul(A, v){ return A.map(row=> row.reduce((s, aij, j)=> s + aij*v[j], 0)); }
  function showLogitResult(beta, cov, ll, iters, X, Y, hasX1, hasX2, negLoss){
    $('#logLik').textContent = isFinite(ll)? ll.toFixed(3): '—';
    $('#iters').textContent = iters;
    const k=beta.length; const aic = -2*ll + 2*k; $('#aic').textContent = isFinite(aic)? aic.toFixed(2): '—';

    // 系数表
    const names=['(Intercept)']; if(hasX1) names.push('x1'); if(hasX2) names.push('x2');
    const tbody=$('#coefBody'); tbody.innerHTML='';
    const se = cov? names.map((_,j)=> Math.sqrt(Math.max(cov[j][j],0))): names.map(()=> NaN);
    for(let j=0;j<names.length;j++){
      const bj=beta[j]; const sej=se[j]; const OR=Math.exp(bj);
      const lo = Math.exp(bj - 1.96*sej); const hi = Math.exp(bj + 1.96*sej);
      const z = bj/(sej||NaN); const p = isFinite(z)? 2*(1-phi(Math.abs(z))): NaN;
      const tr=document.createElement('tr'); tr.style.borderBottom='1px dotted rgba(255,255,255,.1)';
      tr.innerHTML = `<td style="padding:6px 4px">${names[j]}</td><td style="text-align:right">${fix(bj)}</td><td style="text-align:right">${fix(sej)}</td><td style="text-align:right">${fix(OR)}</td><td style="text-align:right">[${fix(lo)}, ${fix(hi)}]</td><td style="text-align:right">${fix(z)}</td><td style="text-align:right">${fix(p)}</td>`;
      tbody.appendChild(tr);
    }
    // 参数选择器
    const sel=$('#paramSel'); sel.innerHTML=''; names.slice(1).forEach((nm,i)=>{ const opt=document.createElement('option'); opt.value=(i+1); opt.textContent=nm; sel.appendChild(opt); });

    // 收敛曲线
    if(lossChart) lossChart.destroy();
    lossChart = new Chart($('#lossChart'), {type:'line', data:{labels:negLoss.map((_,i)=>i+1), datasets:[{label:'-logLik', data:negLoss}]}, options:{responsive:true, plugins:{legend:{display:false}}, scales:{x:{title:{display:true,text:'迭代'}}, y:{title:{display:true,text:'-logLik'}}}}});

    // 二维分界线（仅当同时存在 x1,x2）
    if(boundaryChart) boundaryChart.destroy();
    if(hasX1 && hasX2){
      const xs1 = X.map(r=> r[1]); const xs2 = X.map(r=> r[2]);
      const ys=Y;
      const min1=Math.min(...xs1), max1=Math.max(...xs1); const min2=Math.min(...xs2), max2=Math.max(...xs2);
      const grid=[]; const step1=(max1-min1)||1, step2=(max2-min2)||1;
      for(let t=0;t<=30;t++){
        const x1=min1 + (t/30)* (step1*1.2); const x2 = (-(beta[0]+beta[1]*x1)/(beta[2]||1e-12));
        grid.push({x1, x2});
      }
      const cfg={type:'scatter', data:{datasets:[
        {label:'y=1', data: X.filter((_,i)=> ys[i]===1).map(r=>({x:r[1], y:r[2]}))},
        {label:'y=0', data: X.filter((_,i)=> ys[i]===0).map(r=>({x:r[1], y:r[2]}))},
        {label:'边界 p=0.5', data: grid.map(g=>({x:g.x1, y:g.x2})), showLine:true}
      ]}, options:{responsive:true, plugins:{legend:{position:'bottom'}}, scales:{x:{title:{display:true,text:'x1'}}, y:{title:{display:true,text:'x2'}}}}};
      boundaryChart = new Chart($('#boundaryChart'), cfg);
    }

    lastModel = {beta, cov, ll, X, Y, hasX1, hasX2};
  }
  function phi(z){ // 标准正态分布上侧尾部补：返回 Φ(z)
    // 近似 CDF（Hastings)
    const b1=0.319381530, b2=-0.356563782, b3=1.781477937, b4=-1.821255978, b5=1.330274429; const p=0.2316419;
    const t=1/(1+p*Math.abs(z)); const pdf=Math.exp(-0.5*z*z)/Math.sqrt(2*Math.PI);
    let c=1 - pdf*(b1*t + b2*t*t + b3*t*t*t + b4*Math.pow(t,4) + b5*Math.pow(t,5));
    return z>=0? c : 1-c;
  }
  function fix(x){ return (x===undefined||x===null||Number.isNaN(x))? '—' : (Math.abs(x)>1e6? x.toExponential(2): (Math.abs(x)<1e-4? x.toExponential(2): x.toFixed(3))); }

  // ===== Tests: Wald / LRT / Score =====
  function runTests(){
    if(!lastModel){ alert('请先拟合模型'); return; }
    const {beta, cov, ll, X, Y} = lastModel; const j = parseInt($('#paramSel').value); if(!(j>=1)) return;
    // Wald
    const se = Math.sqrt(Math.max(cov?cov[j][j]:NaN, 0)); const z = beta[j]/(se||NaN);
    $('#waldZ').textContent = fix(z);

    // LRT：约束模型 βj=0 重新拟合
    const mask = Array(beta.length).fill(1); mask[j]=0; const l0 = fitWithMask(X, Y, mask);
    const lrt = 2*(ll - l0);
    $('#lrtChi').textContent = fix(lrt);

    // Score：在 βj=0, 其它为 0 的点评估 U 与 I
    const U = scoreAtZero(X,Y); const I = fisherAtZero(X,Y);
    // 取单参数的得分与信息（剔除截距）
    const Uj = U[j], Ijj = I[j][j]; const score = Uj*Uj/(Ijj||1e-12);
    $('#scoreChi').textContent = fix(score);

    drawTestChart(ll, l0);
  }
  function fitWithMask(X, Y, mask){
    // 约束 βj=0：把该列从设计矩阵移除再拟合，得到 logLik0
    const keepIdx = mask.map((v,i)=> v? i: -1).filter(i=> i>=0);
    const Xr = X.map(row=> keepIdx.map(k=> row[k]));
    // 简单 IRLS 以求 logLik
    let beta = Array(keepIdx.length).fill(0), lastLL=-Infinity;
    for(let it=0; it<40; it++){
      const eta = matVecMul(Xr, beta); const mu=eta.map(sigmoid);
      const W = mu.map(m=> m*(1-m)); const z = eta.map((e,i)=> e + (Y[i]-mu[i])/Math.max(W[i],1e-12));
      const Xt = transpose(Xr); const WX = Xr.map((row,i)=> row.map(v=> v*W[i]));
      const XtWX = matMul(Xt, WX); const XtWz = matVecMul(Xt, z.map((zi,i)=> zi*W[i]));
      // 求逆
      let Hinv=null;
      if(XtWX.length===3){ Hinv = invSym3(XtWX); }
      else if(XtWX.length===2){ const a=XtWX[0][0], b=XtWX[0][1], c=XtWX[1][1]; const det=a*c-b*b; Hinv = (Math.abs(det)<1e-12)? null : [[c/det,-b/det],[-b/det,a/det]]; }
      else { Hinv = [[1/Math.max(XtWX[0][0],1e-12)]]; }
      if(!Hinv) break;
      const delta = matVecMul(Hinv, XtWz); for(let j=0;j<beta.length;j++) beta[j]=delta[j];
      const ll = sum(mu.map((m,i)=> Y[i]*Math.log(clamp(m,1e-12,1-1e-12)) + (1-Y[i])*Math.log(clamp(1-m,1e-12,1-1e-12))));
      if(Math.abs(ll-lastLL)<1e-7){ return ll; } lastLL=ll;
    }
    return lastLL;
  }
  function scoreAtZero(X,Y){ // β=0 → η=0 → p=0.5
    const p=0.5; const U = Array(X[0].length).fill(0);
    for(let i=0;i<Y.length;i++){
      const wi = (Y[i]-p);
      for(let j=0;j<X[0].length;j++) U[j]+= X[i][j]*wi;
    }
    return U;
  }
  function fisherAtZero(X,Y){ // I = Σ p(1-p) x x^T, p=0.5
    const npar=X[0].length; const I=Array.from({length:npar},()=>Array(npar).fill(0));
    for(let i=0;i<Y.length;i++){
      for(let j=0;j<npar;j++) for(let k=0;k<npar;k++) I[j][k]+= 0.25 * X[i][j]*X[i][k];
    }
    return I;
  }
  function drawTestChart(ll, l0){
    if(testChart) testChart.destroy();
    testChart = new Chart($('#testChart'), {type:'bar', data:{labels:['全模型 logL','约束模型 logL'], datasets:[{data:[ll,l0]}]}, options:{responsive:true, plugins:{legend:{display:false}}, scales:{y:{title:{display:true,text:'logLik'}}}}});
  }

  // ===== Diagnostics =====
  function showCorr(){
    if(!lastModel){ alert('请先拟合模型'); return; }
    const {X, hasX1, hasX2} = lastModel; const names=['(Intercept)']; if(hasX1) names.push('x1'); if(hasX2) names.push('x2');
    const cols = names.length, n=X.length; const M=Array.from({length:cols},()=>Array(n));
    for(let j=0;j<cols;j++) for(let i=0;i<n;i++) M[j][i]=X[i][j];
    function corr(a,b){ const ma=mean(a), mb=mean(b); let num=0, da=0, db=0; for(let i=0;i<a.length;i++){ const xa=a[i]-ma, xb=b[i]-mb; num+=xa*xb; da+=xa*xa; db+=xb*xb; } return num/Math.sqrt(Math.max(da*db,1e-12)); }
    let out='相关系数矩阵\n';
    for(let j=0;j<cols;j++){
      for(let k=0;k<cols;k++) out+= (j===k? '1.000' : corr(M[j],M[k]).toFixed(3)) + (k===cols-1?'':'\t');
      out+='\n';
    }
    $('#corrBox').textContent = out;
  }
</script>
</body>
</html>
