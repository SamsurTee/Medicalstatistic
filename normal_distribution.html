<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Normal Distribution - Double Tail Area</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <style>
        body {
            font-family: Arial, sans-serif;
            padding: 20px;
        }
        .container {
            max-width: 900px;
            margin: auto;
        }
        label, h2 {
            margin-top: 20px;
        }
        input[type="range"], input[type="number"] {
            width: 100%;
            margin-top: 10px;
        }
        .input-group {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        .input-group input[type="number"] {
            width: 100px;
        }
    </style>
</head>
<body>
    <div class="container">
        <h2>Normal Distribution Curve - Double Tail Area Highlight</h2>
        <canvas id="normalChart" width="800" height="400"></canvas>
        <br>
        <label for="zValueRange">Z Value (双尾):</label>
        
        <div class="input-group">
            <input type="range" id="zValueRange" min="0" max="4" value="1.000" step="0.001" oninput="syncInputsFromRange()">
            <input type="number" id="zValueInput" min="0" max="4" value="1.000" step="0.001" oninput="syncRangeFromInput()" onchange="validateInput()">
        </div>
        
        <p>当前 Z 值：<span id="zDisplay">1.000</span></p>
        <p>双尾区域面积（概率）：<span id="areaDisplay">0.317</span></p>
    </div>

    <script>
        const ctx = document.getElementById('normalChart').getContext('2d');

        function normalPDF(x, mean = 0, std = 1) {
            return (1 / (std * Math.sqrt(2 * Math.PI))) * Math.exp(-0.5 * ((x - mean) / std) ** 2);
        }

        function normalCDF(x, mean = 0, std = 1) {
            return 0.5 * (1 + erf((x - mean) / (std * Math.sqrt(2))));
        }

        function erf(x) {
            const a1 =  0.254829592;
            const a2 = -0.284496736;
            const a3 =  1.421413741;
            const a4 = -1.453152027;
            const a5 =  1.061405429;
            const p  =  0.3275911;

            const sign = x < 0 ? -1 : 1;
            x = Math.abs(x);

            const t = 1 / (1 + p * x);
            const y = 1 - (((((a5 * t + a4) * t) + a3) * t + a2) * t + a1) * t * Math.exp(-x * x);

            return sign * y;
        }

        const dataPoints = [];
        for (let i = -4; i <= 4; i += 0.01) {
            const x = parseFloat(i.toFixed(3));
            const y = normalPDF(x);
            dataPoints.push({ x: x, y: y });
        }

        const normalChart = new Chart(ctx, {
            type: 'scatter',
            data: {
                datasets: [{
                    label: 'Normal Distribution',
                    data: dataPoints,
                    showLine: true,
                    borderColor: 'blue',
                    borderWidth: 3,
                    fill: false,
                    pointRadius: 0
                }, {
                    label: 'Double Tail Area',
                    data: [],
                    showLine: true,
                    backgroundColor: 'rgba(135,206,250,0.5)',
                    fill: true,
                    pointRadius: 0
                }]
            },
            options: {
                scales: {
                    x: {
                        title: { display: true, text: 'Z-score' },
                        ticks: {
                            callback: function(value) {
                                return parseFloat(value).toFixed(3);
                            }
                        }
                    },
                    y: {
                        title: { display: true, text: 'Probability Density' },
                        min: 0
                    }
                },
                plugins: {
                    legend: {
                        labels: {
                            boxWidth: 20,
                            font: { size: 14 }
                        }
                    }
                }
            }
        });

        const rangeEl = document.getElementById('zValueRange');
        const inputEl = document.getElementById('zValueInput');

        function syncInputsFromRange() {
            const val = parseFloat(rangeEl.value).toFixed(3);
            inputEl.value = val;
            updateChart(val);
        }

        function syncRangeFromInput() {
            const val = inputEl.value;
            if (val === "") {
                // 清空输入时不做任何处理，等待用户输入
                return;
            }
            const floatVal = parseFloat(val).toFixed(3);
            rangeEl.value = floatVal;
        }

        function validateInput() {
            let val = inputEl.value;
            if (val === "" || isNaN(val)) {
                val = 0; // 默认为 0
            }

            val = parseFloat(val);
            if (val < 0) val = 0;
            if (val > 4) val = 4;

            val = val.toFixed(3);
            inputEl.value = val;
            rangeEl.value = val;

            updateChart(val);
        }

        function updateChart(zVal) {
            const zValue = parseFloat(parseFloat(zVal).toFixed(3));
            document.getElementById('zDisplay').innerText = zValue.toFixed(3);

            const area = 2 * (1 - normalCDF(zValue));
            document.getElementById('areaDisplay').innerText = area.toFixed(3);

            const shadedData = dataPoints.map(point => {
                if (point.x <= -zValue || point.x >= zValue) {
                    return { x: point.x, y: point.y };
                } else {
                    return { x: point.x, y: null };
                }
            });

            normalChart.data.datasets[1].data = shadedData;
            normalChart.update();
        }

        // 初始化同步
        syncInputsFromRange();
    </script>
</body>
</html>